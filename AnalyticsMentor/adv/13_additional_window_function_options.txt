	/*
	we can do more advanced window functions than what we've been
	doing up to this point.
	
	let's say that we want to calculate a cumulative sum of values
	as a running total.

	i want to copy past this code in, and let's look at the output.

	now, i want to hae a running total of sales. we can do this
	with some more advanced functions.
*/


with transaction_totals as (
	select
		  ti.transaction_id
		, sum(p.price) as price
	from
		transaction_items ti

			join products p
			   on p.product_id = ti.product_id
	group by
		ti.transaction_id
)

, daily_sales_summary as (
	select
		t.trans_dt
	  , sum(ti.price) as total_sales
	from
		transactions t

			join transaction_totals ti
				on t.transaction_id = ti.transaction_id
	group by
		t.trans_dt
	order by
		t.trans_dt
)

select
	d.trans_dt
  , d.total_sales
  , sum(d.total_sales) over(order by d.trans_dt) as running_total_sales
from
	daily_sales_summary d
order by
	d.trans_dt

/*
	be
*/



with transaction_totals as (
	select
		  ti.transaction_id
		, sum(p.price) as price
	from
		transaction_items ti

			join products p
			   on p.product_id = ti.product_id
	group by
		ti.transaction_id
)

, daily_sales_summary as (
	select
		t.trans_dt
	  , sum(ti.price) as total_sales
	from
		transactions t

			join transaction_totals ti
				on t.transaction_id = ti.transaction_id
	group by
		t.trans_dt
	order by
		t.trans_dt
)

select
	d.trans_dt
  , d.total_sales
  , sum(d.total_sales) over(order by d.trans_dt rows between unbounded preceding and current row) as running_total_sales
from
	daily_sales_summary d
order by
	d.trans_dt

/*
we can see that the results don't change cause that's what occuring behind he scenses
*/	
	
/*
	you can also do this in the reverse direction
*/
with transaction_totals as (
	select
		  ti.transaction_id
		, sum(p.price) as price
	from
		transaction_items ti

			join products p
			   on p.product_id = ti.product_id
	group by
		ti.transaction_id
)

, daily_sales_summary as (
	select
		t.trans_dt
	  , sum(ti.price) as total_sales
	from
		transactions t

			join transaction_totals ti
				on t.transaction_id = ti.transaction_id
	group by
		t.trans_dt
	order by
		t.trans_dt
)

select
	d.trans_dt
  , d.total_sales
  , sum(d.total_sales) over(order by d.trans_dt desc rows between current row and unbounded following) as running_total_sales
from
	daily_sales_summary d
order by
	d.trans_dt
	/*
		you can see that it summed in reverse direction with 2020-01-01 having the total of all records with an earlier date.
	*/
	
/*
	and you can lmit the number of rows that you want to have in your window function
	to sum over. it doesn't have to be every row.
	
	if we look a few rows down and then add up the values, you can see that it's
	only looking at the last 3 to sum the values, not all prior
*/
with transaction_totals as (
	select
		  ti.transaction_id
		, sum(p.price) as price
	from
		transaction_items ti

			join products p
			   on p.product_id = ti.product_id
	group by
		ti.transaction_id
)

, daily_sales_summary as (
	select
		t.trans_dt
	  , sum(ti.price) as total_sales
	from
		transactions t

			join transaction_totals ti
				on t.transaction_id = ti.transaction_id
	group by
		t.trans_dt
	order by
		t.trans_dt
)

select
	d.trans_dt
  , d.total_sales
  , sum(d.total_sales) over(order by d.trans_dt rows between 2 preceding and current row) as total_sales_trailing_3d
from
	daily_sales_summary d
order by
	d.trans_dt
	
	
/*
	and you can lmit the number of rows that you want to have in your window function
	to sum over. it doesn't have to be every row.
	
	you can even do a combination of rows preceding and following
*/
with transaction_totals as (
	select
		  ti.transaction_id
		, sum(p.price) as price
	from
		transaction_items ti

			join products p
			   on p.product_id = ti.product_id
	group by
		ti.transaction_id
)

, daily_sales_summary as (
	select
		t.trans_dt
	  , sum(ti.price) as total_sales
	from
		transactions t

			join transaction_totals ti
				on t.transaction_id = ti.transaction_id
	group by
		t.trans_dt
	order by
		t.trans_dt
)

select
	d.trans_dt
  , d.total_sales
  , sum(d.total_sales) over(order by d.trans_dt rows between 1 preceding and 1 following) as total_sales_1d_around
from
	daily_sales_summary d
order by
	d.trans_dt





/*
	where this can become more useful is rolling averages.
	now i'm going to cast this as an integer to make it a bit easier to
	read
*/
with transaction_totals as (
	select
		  ti.transaction_id
		, sum(p.price) as price
	from
		transaction_items ti

			join products p
			   on p.product_id = ti.product_id
	group by
		ti.transaction_id
)

, daily_sales_summary as (
	select
		t.trans_dt
	  , sum(ti.price) as total_sales
	from
		transactions t

			join transaction_totals ti
				on t.transaction_id = ti.transaction_id
	group by
		t.trans_dt
	order by
		t.trans_dt
)

select
	d.trans_dt
  , d.total_sales
  , cast( 
	  		avg(d.total_sales) over(order by d.trans_dt rows between 2 preceding and current row)
	     as int) as total_sales_trailing_3d
from
	daily_sales_summary d
order by
	d.trans_dt